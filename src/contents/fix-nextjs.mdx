---
title: Next.js 踩坑指南
category:
  - Troubleshooting
slug: fix-nextjs
summary: 记录使用 nextjs 过程中踩过的坑，以及对应的解决思路与经验总结。
createdTime: '2025-11-24 10:00:00'
updatedTime: '2025-12-15 15:57:00'
---

import { Tabs, TabItem } from '@/components/tabs';

# useSearchParams

该 hook 只能在客户端组件中使用，且需要包裹在 Suspense 中，否则 build 会产生警告。

# Middleware set coockie

由于浏览器安全策略，middleware 中 cookie-set 操作，需要在 https、域名 下才能正常执行。

`setCookie.options` 配置 `httpOnly、secure` 为 false，可以规避该问题，但是存在安全风险。

> 除了本地开发环境，localhost 域被认作为安全域。

```js title="AuthCenterMiddleware.ts"
/* 检查 sessionId 是否存在 并存储 cookie */
const AuthCenterMiddleware = (req: NextRequest) => {
  const { searchParams } = req.nextUrl;
  const sessionId = searchParams.get(SESSION_KEY_IN_URL);

  /* 如果 URL 带 sessionId，则存 Cookie */
  if (sessionId) {
    const url = req.nextUrl;

    /* 删除 sessionId 参数 */
    url.searchParams.delete(SESSION_KEY_IN_URL);

    const res = NextResponse.redirect(url);

    res.cookies.set(SESSION_KEY_IN_COOKIE, sessionId, {
      httpOnly: false,
      secure: false,
      path: '/',
      sameSite: 'lax',
      expires: new Date(Date.now() + 1000 * 60 * 60 * 6), // 6 hours
      // expires: new Date(Date.now() + 1000 * 10),
    });

    return res;
  }

  return NextResponse.next();
};
```

# fetcher 封装

<Tabs>
  <TabItem label="fetcher.ts">
    ```ts
    // @ts-nocheck
    
    import { saveAs } from 'file-saver';
    import qs from 'qs';
    import { isBlobResponse, isBrowser, parseFilenameFromHeaders } from './utils';
    
    type Method = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    
    type RequestOptions = Omit<RequestInit, 'method' | 'body'>;
    
    interface RequestProps {
      url: string;
      method: Method;
      params?: any;
      options?: RequestOptions;
    }
    
    interface DownloadPostOptions extends RequestOptions {
      filename?: string;
      method?: Method;
    }
    
    /**
     * 请求拦截器
     */
    function interceptorsRequest({ url, method, params, options }: RequestProps) {
      let finalUrl = url;
      let payload: BodyInit | undefined = undefined;
    
      const headers: HeadersInit = {
        ...(options?.headers || {}),
      };
    
      const isGetLike = method === 'GET' || method === 'DELETE';
      const isFormData =
        params &&
        (Object.prototype.toString.call(params) === '[object FormData]' ||
          Object.prototype.toString.call(params) === '[object URLSearchParams]');
    
      // 处理 GET/DELETE Query 拼接
      if (isGetLike && params && Object.keys(params).length > 0) {
        finalUrl +=
          (finalUrl.includes('?') ? '&' : '?') + qs.stringify(params, { arrayFormat: 'indices' });
      } else if (params !== undefined && params !== null) {
        // 非 GET/DELETE，处理请求体
        if (isFormData) {
          payload = params;
          // 不设置 Content-Type, 让浏览器自动推断，避免边界问题
        } else {
          headers['Content-Type'] = 'application/json';
          payload = JSON.stringify(params);
        }
      }
    
      return {
        url: finalUrl,
        options: {
          ...options,
          method,
          body: isGetLike ? undefined : payload,
          headers,
        } as RequestInit,
      };
    }
    
    /**
     * 响应拦截器
     */
    async function interceptorsResponse<T>(res: Response): Promise<T> {
      const requestUrl = res.url;
    
      // 判断返回是不是 blob
      const contentType = res.headers.get('content-type') || '';
      const isBlob = isBlobResponse(contentType);
    
      // 如果是 blob 类型，直接返回 blob，避免重复读取响应
      if (isBlob) {
        return (await res.blob()) as T;
      }
    
      // 非 blob 类型，读取文本内容用于 JSON 解析或错误处理
      const text = await res.text();
    
      if (res.ok) {
        try {
          const response = JSON.parse(text);
    
          if (response.code === 401) {
            throw new Error('未授权，请先登录');
          }
    
          return response as T;
        } catch (err) {
          console.error('akira.err', err);
          // 如果不是有效的 JSON，返回原始文本
          return text as T;
        }
      }
    
      // 处理错误响应
      try {
        const errorData = JSON.parse(text);
        throw {
          message: errorData?.message || errorData || '接口错误',
          url: requestUrl,
          status: res.status,
        };
      } catch {
        throw { message: text || '接口错误', url: requestUrl, status: res.status };
      }
    }
    
    /**
     * 主请求函数
     */
    export async function request<T>({
      url = '',
      params = {},
      method,
      options,
    }: RequestProps): Promise<T> {
      const req = interceptorsRequest({ url, method, params, options });
      const res = await fetch(req.url, req.options);
      return interceptorsResponse<T>(res);
    }
    
    export function get<T>(url: string, params?: any, options?: RequestOptions) {
      return request<T>({ url, method: 'GET', params, options });
    }
    
    export function post<T>(url: string, params?: any, options?: RequestOptions) {
      return request<T>({ url, method: 'POST', params, options });
    }
    
    export function put<T>(url: string, params?: any, options?: RequestOptions) {
      return request<T>({ url, method: 'PUT', params, options });
    }
    
    export function del<T>(url: string, params?: any, options?: RequestOptions) {
      return request<T>({ url, method: 'DELETE', params, options });
    }
    
    export function patch<T>(url: string, params?: any, options?: RequestOptions) {
      return request<T>({ url, method: 'PATCH', params, options });
    }
    
    export async function download(
      url: string,
      params?: any,
      options?: DownloadPostOptions,
    ): Promise<void> {
      if (!isBrowser) throw new Error('downloadPost 只能在浏览器环境中使用');
    
      const { method = 'POST', filename: defaultFilename = 'download' } = options || {};
    
      const req = interceptorsRequest({ url, method, params, options });
      const res = await fetch(req.url, req.options);
    
      // 检查响应状态
      if (!res.ok) {
        const text = await res.text();
        try {
          const errorData = JSON.parse(text);
          throw new Error(errorData?.message || errorData || '下载失败');
        } catch {
          throw new Error(text || '下载失败');
        }
      }
      // 获取 blob
      const blob = await res.blob();
      // 解析文件名
      const filename = parseFilenameFromHeaders(res.headers, defaultFilename);
      // 使用 file-saver 下载文件
      saveAs(blob, filename);
    }
    
    ```
  </TabItem>
  <TabItem label="utils.ts">
  ```ts
  /* 判断是否为浏览器环境 */
  export const isBrowser = !!(
    typeof window !== 'undefined' &&
    window.document &&
    window.document.createElement
  );
  
  /**
   * 判断响应是否为 blob 类型
   */
  export const isBlobResponse = (contentType: string): boolean => {
    return (
      contentType.includes('application/octet-stream') ||
      contentType.includes('application/vnd') ||
      contentType.includes('application/pdf') ||
      contentType.includes('image/') ||
      contentType.includes('audio/') ||
      contentType.includes('video/') ||
      contentType.includes('application/zip') ||
      contentType.includes('application/x-') ||
      (contentType.startsWith('application/') && !contentType.includes('json'))
    );
  };
  
  /**
   * 从响应头中解析文件名
   */
  export const parseFilenameFromHeaders = (headers: Headers, defaultFilename?: string): string => {
    const contentDisposition = headers.get('content-disposition');
    if (contentDisposition) {
      // 处理 filename*=UTF-8''xxx 格式
      const utf8FilenameMatch = contentDisposition.match(/filename\*=UTF-8''(.+)/i);
      if (utf8FilenameMatch) {
        return decodeURIComponent(utf8FilenameMatch[1]);
      }
      // 处理 filename="xxx" 或 filename=xxx 格式
      const filenameMatch = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/i);
      if (filenameMatch && filenameMatch[1]) {
        return filenameMatch[1].replace(/['"]/g, '');
      }
    }
    return defaultFilename || 'download';
  };
  
  ```
  </TabItem>
</Tabs>