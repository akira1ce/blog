---
title: Next.js åšå®¢å¼€å‘
category: ['Frontend']
slug: fe-nextjs-blog-build
date: 2025-08-11
summary: 'ä¸€ä¸ªä½¿ç”¨ Next.js å’Œ MDX æ„å»ºçš„ç°ä»£åŒ–åšå®¢ç³»ç»Ÿï¼Œæ”¯æŒä¸»é¢˜åˆ‡æ¢ã€ä»£ç é«˜äº®å’Œé¡µé¢è¿‡æ¸¡åŠ¨ç”»'
---

import { Tabs, TabItem } from '@/components/tabs';

# æŠ€æœ¯é€‰å‹

æœ¬æ–‡å°†è¯¦ç»†ä»‹ç»ä¸€ä¸ªåŸºäº Next.js 15 æ„å»ºçš„ç°ä»£åŒ–åšå®¢ç³»ç»Ÿçš„æŠ€æœ¯å®ç°ï¼Œä¸»è¦æ¶µç›–ä»¥ä¸‹å‡ ä¸ªæ ¸å¿ƒåŠŸèƒ½ï¼š

- **ä»£ç é«˜äº®ç³»ç»Ÿ** - åŸºäº Shiki çš„è¯­æ³•é«˜äº®
- **ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½** - æ”¯æŒæ˜æš—ä¸»é¢˜æ— ç¼åˆ‡æ¢
- **æ–‡ç« ç´¢å¼•ç¼“å­˜** - åŸºäº JSON çš„æ–‡ç« å…ƒæ•°æ®ç¼“å­˜
- **MDX æ¸²æŸ“å¼•æ“** - æ”¯æŒ React ç»„ä»¶çš„ Markdown æ¸²æŸ“
- **Markdown æ ·å¼** - åŸºäº Tailwind CSS Typography çš„æ ·å¼ç³»ç»Ÿ

# ç›®å½•ç»“æ„

```
blog/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/                   # Next.js App Router
â”‚   â”‚   â”œâ”€â”€ posts/[slug]/      # åŠ¨æ€è·¯ç”±
â”‚   â”‚   â””â”€â”€ components/        # åº”ç”¨çº§ç»„ä»¶
â”‚   â”œâ”€â”€ components/            # å¯å¤ç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ contents/              # MDX æ–‡ç« 
â”‚   â”œâ”€â”€ lib/                   # å·¥å…·å‡½æ•°
â”‚   â””â”€â”€ hooks/                 # è‡ªå®šä¹‰ Hooks
â”œâ”€â”€ scripts/                   # æ„å»ºè„šæœ¬
â”œâ”€â”€ public/                    # é™æ€èµ„æº
â””â”€â”€ mdx-components.tsx         # MDX ç»„ä»¶é…ç½®
```

# ä»£ç é«˜äº®

é¡¹ç›®é‡‡ç”¨ **Shiki** ä½œä¸ºä»£ç é«˜äº®å¼•æ“ï¼Œé€šè¿‡ **rehype-pretty-code** æ’ä»¶é›†æˆåˆ° MDX å¤„ç†æµç¨‹ä¸­ã€‚

```json
{
  "dependencies": {
    "rehype-pretty-code": "^0.14.1",
    "shiki": "^3.6.0"
  }
}
```

<Tabs>
  <TabItem label="next.config.mjs">
    ```javascript
    import nextMDX from '@next/mdx';
    import rehypePrettyCode from 'rehype-pretty-code';
    import rehypeSlug from 'rehype-slug';
    import remarkFrontmatter from 'remark-frontmatter';
    import remarkGfm from 'remark-gfm';

    /** @type {import('rehype-pretty-code').Options} */
    const options = {
      /* æ˜¯å¦ä¿ç•™èƒŒæ™¯è‰² */
      keepBackground: false,
      defaultLang: 'typescript',
      theme: {
        light: 'github-light',
        dark: 'github-dark',
      },
    };

    const withMDX = nextMDX({
      extension: /\.(md|mdx)$/,
      options: {
        remarkPlugins: [remarkFrontmatter, remarkGfm],
        rehypePlugins: [[rehypePrettyCode, options], [rehypeSlug]],
      },
    });

    export default withMDX(nextConfig);
    ```
  </TabItem>
</Tabs>

é€šè¿‡ CSS å˜é‡å®ç°ä¸»é¢˜é€‚é…çš„ä»£ç é«˜äº®ï¼š

```css
/* globals.css */
html {
  &.light {
    .shiki,
    .shiki span {
      color: var(--shiki-light) !important;
      background-color: var(--shiki-light-bg) !important;
    }
  }

  &.dark {
    .shiki,
    .shiki span {
      color: var(--shiki-dark) !important;
      background-color: var(--shiki-dark-bg) !important;
    }
  }
}
```

## å¤åˆ¶åŠŸèƒ½

<Tabs>
  <TabItem label="code.tsx">
    ```tsx
    'use client';

    import { Check, Copy } from 'lucide-react';
    import { useRef, useState } from 'react';

    interface CodeProps {
      children: string;
      className?: string;
      [key: string]: any;
    }

    const Code = ({ children, className, ...props }: CodeProps) => {
      const [copied, setCopied] = useState(false);
      const preRef = useRef<HTMLPreElement>(null);

      const handleCopy = async () => {
        try {
          await navigator.clipboard.writeText(preRef.current?.innerText || '');
          setCopied(true);
          setTimeout(() => setCopied(false), 2000);
        } catch (err) {
          console.error('Failed to copy text: ', err);
        }
      };

      return (
        <div className="group relative">
          <pre ref={preRef} className={className} {...props}>
            {children}
          </pre>
          <button
            onClick={handleCopy}
            className="bg-fore/20 hover:bg-fore/10 absolute top-2 right-2 rounded-xl p-2 text-xs opacity-0 transition-opacity duration-200 group-hover:opacity-100"
            aria-label="Copy code"
          >
            {copied ? <Check size={16} /> : <Copy size={16} />}
          </button>
        </div>
      );
    };

    export default Code;
    ```
  </TabItem>
</Tabs>

é€šè¿‡ `mdx-components.tsx` å°†è‡ªå®šä¹‰ç»„ä»¶æ˜ å°„åˆ° MDXï¼š

```tsx
import type { MDXComponents } from 'mdx/types';
import Code from './src/components/code';

export function useMDXComponents(components: MDXComponents): MDXComponents {
  return {
    ...components,
    pre: Code, // å°† pre æ ‡ç­¾æ›¿æ¢ä¸ºè‡ªå®šä¹‰ç»„ä»¶
  };
}
```

# Dark Theme

ä½¿ç”¨ **next-themes** åº“å®ç°ä¸»é¢˜ç®¡ç†ï¼Œç»“åˆ **View Transition API** æä¾›æµç•…çš„åˆ‡æ¢åŠ¨ç”»ã€‚

<Tabs>
  <TabItem label="theme-provider.tsx">
    ```tsx
    'use client';

    import { ThemeProvider as NextThemesProvider } from 'next-themes';
    import type { ThemeProviderProps } from 'next-themes';

    export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
      return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
    }
    ```
  </TabItem>
  <TabItem label="layout.tsx">
    ```tsx
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en" suppressHydrationWarning>
          <body className={`${mapleMono.className} bg-main w-full antialiased`}>
            <ThemeProvider attribute="class" defaultTheme="system">
              <Header />
              <main className="m-auto w-3/4 py-10">{children}</main>
            </ThemeProvider>
          </body>
        </html>
      );
    }
    ```
  </TabItem>
  <TabItem label="theme-toggle.tsx">
    ```tsx
    'use client';

    import { useTheme } from 'next-themes';
    import { Sun, Moon } from 'lucide-react';
    import { useEffect, useState } from 'react';

    export function ThemeToggle() {
      const { theme, setTheme, systemTheme } = useTheme();
      const [mounted, setMounted] = useState(false);

      /* åˆ‡æ¢ä¸»é¢˜ */
      const handleThemeToggle = () => {
        const switchTheme = () => {
          setTheme(theme === 'dark' ? 'light' : 'dark');
        };

        // ä½¿ç”¨ View Transition API å®ç°åŠ¨ç”»
        if (!document.startViewTransition) switchTheme();
        else document.startViewTransition(switchTheme);
      };

      /* ç¡®ä¿ç»„ä»¶æŒ‚è½½åå†æ¸²æŸ“ï¼Œé¿å…æ°´åˆä¸åŒ¹é… */
      useEffect(() => {
        setMounted(true);
      }, []);

      // é˜²æ­¢æ°´åˆä¸åŒ¹é…çš„å ä½ç¬¦
      if (!mounted) {
        return (
          <button className="flex h-9 w-9 items-center justify-center rounded-xl">
            <div className="h-4 w-4" />
          </button>
        );
      }

      return (
        <button
          onClick={handleThemeToggle}
          className="flex h-9 w-9 cursor-pointer items-center justify-center rounded-full transition-all duration-300 hover:scale-120 hover:rotate-270"
          aria-label="åˆ‡æ¢ä¸»é¢˜"
        >
          {theme === 'dark' ? (
            <Sun className="text-fore dark:text-fore h-4 w-4" />
          ) : (
            <Moon className="text-fore dark:text-fore h-4 w-4" />
          )}
        </button>
      );
    }
    ```
  </TabItem>
</Tabs>

## CSS Variables

ä½¿ç”¨ Tailwind CSS 4 çš„æ–°ç‰¹æ€§å®ç°ä¸»é¢˜å˜é‡ï¼š

```css
@import 'tailwindcss';
@plugin "@tailwindcss/typography";

/* å£°æ˜æš—é»‘æ¨¡å¼ä¸º class æ¨¡å¼ */
@custom-variant dark (&:where(.dark, .dark *));

@layer base {
  html {
    &.light {
      --bg-main: #ffffff;
      --bg-fore: #09090b;
      --bg-card: #fafafa;
    }

    &.dark {
      --bg-main: #09090b;
      --bg-fore: #ffffff;
      --bg-card: #18181b;
    }
  }
}

/* å°† CSS å˜é‡æ˜ å°„åˆ° Tailwind ç±»å */
@theme inline {
  --color-main: var(--bg-main);
  --color-fore: var(--bg-fore);
  --color-card: var(--bg-card);
}
```

## View Transition åŠ¨ç”»

```css
/* ä¸»é¢˜åˆ‡æ¢åŠ¨ç”» */
::view-transition-group(root) {
  animation-timing-function: var(--expo-out);
}

::view-transition-new(root) {
  mask: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><defs><filter id="blur"><feGaussianBlur stdDeviation="2"/></filter></defs><circle cx="0" cy="0" r="18" fill="white" filter="url(%23blur)"/></svg>')
    top left / 0 no-repeat;
  mask-origin: content-box;
  animation: scale 1s forwards;
  transform-origin: top left;
}

::view-transition-old(root) {
  animation: scale 1s;
  transform-origin: top left;
  z-index: -1;
}

@keyframes scale {
  to {
    mask-size: 350vmax;
  }
}
```

# æ–‡ç« ç´¢å¼•ç¼“å­˜

ä¸ºäº†æå‡æ€§èƒ½ï¼Œåšå®¢ç³»ç»Ÿé‡‡ç”¨é¢„æ„å»ºçš„ JSON ç´¢å¼•æ–‡ä»¶æ¥å­˜å‚¨æ‰€æœ‰æ–‡ç« çš„å…ƒæ•°æ®ï¼Œé¿å…è¿è¡Œæ—¶é¢‘ç¹çš„æ–‡ä»¶ç³»ç»Ÿæ“ä½œã€‚

<Tabs>
  <TabItem label="gen-posts-index.js">
    ```javascript
    import fs from 'fs';
    import path from 'path';
    import matter from 'gray-matter';

    const POSTS_DIR = path.join(process.cwd(), 'src/contents');
    const OUTPUT_FILE = path.join(process.cwd(), 'public/posts-index.json');

    /**
     * å¤„ç†å•ä¸ªæ–‡ç« æ–‡ä»¶
     */
    function processPostFile(file) {
      try {
        const filePath = path.join(POSTS_DIR, file);
        const content = fs.readFileSync(filePath, 'utf-8');
        const { data } = matter(content);

        // éªŒè¯å¿…è¦å­—æ®µ
        if (!data.slug || !data.title || !data.date) {
          console.warn(`âš ï¸  Missing required fields in ${file}`);
          return null;
        }

        return {
          slug: data.slug,
          title: data.title,
          date: data.date.toLocaleDateString('zh-CN', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
          }),
          summary: data.summary || '',
          category: data.category || 'uncategorized',
        };
      } catch (error) {
        console.error(`âŒ Error processing file ${file}:`, error.message);
        return null;
      }
    }

    /**
     * ç”Ÿæˆæ–‡ç« ç´¢å¼•
     */
    function generatePostsIndex() {
      try {
        console.log('ğŸš€ Starting posts index generation...');
        
        const files = fs.readdirSync(POSTS_DIR).filter((file) => file.endsWith('.mdx'));
        console.log(`ğŸ“‚ Found ${files.length} MDX files`);

        const posts = files
          .map((file) => processPostFile(file))
          .filter(Boolean)
          .sort((a, b) => new Date(b.date) - new Date(a.date));

        fs.writeFileSync(OUTPUT_FILE, JSON.stringify(posts, null, 2), 'utf-8');
        console.log(`âœ… Generated index with ${posts.length} posts`);
      } catch (error) {
        console.error('âŒ Error generating posts index:', error.message);
        process.exit(1);
      }
    }

    generatePostsIndex();
    ```
  </TabItem>
    <TabItem label="posts.ts">
    ```typescript
    import fs from 'fs';
    import path from 'path';

    const POSTS_INDEX_PATH = path.join(process.cwd(), 'public/posts-index.json');

    export interface FrontMatter {
      title: string;
      category: string[];
      slug: string;
      date: string;
      summary: string;
    }

    // è·å–æ‰€æœ‰æ–‡ç« 
    export async function getAllPosts(): Promise<FrontMatter[]> {
      try {
        const indexContent = await fs.promises.readFile(POSTS_INDEX_PATH, 'utf-8');
        const posts = JSON.parse(indexContent);
        return posts;
      } catch (error) {
        console.error('Error loading posts from index:', error);
        return [];
      }
    }

    /* è·å–å•ç¯‡æ–‡ç«  */
    export async function getPostBySlug(slug: string) {
      const posts = await getAllPosts();
      return posts.find((post) => post.slug === slug) || null;
    }

    /* è·å–æ‰€æœ‰åˆ†ç±» */
    export async function getCategories() {
      const posts = await getAllPosts();
      const categoryCount: { [key: string]: number } = {};

      posts.forEach((post) => {
        const categories = Array.isArray(post.category) ? post.category : [post.category];
        categories.forEach((category) => {
          categoryCount[category] = (categoryCount[category] || 0) + 1;
        });
      });

      return Object.keys(categoryCount)
        .sort()
        .map((category) => ({
          name: category,
          count: categoryCount[category],
        }));
    }

    /* æ ¹æ®åˆ†ç±»è·å–æ–‡ç«  */
    export async function getPostsByCategory(category: string) {
      const posts = await getAllPosts();
      return posts.filter((p) => {
        const categories = Array.isArray(p.category) ? p.category : [p.category];
        return categories.includes(category);
      });
    }
    ```
  </TabItem>
</Tabs>

åœ¨ `package.json` ä¸­é›†æˆç´¢å¼•ç”Ÿæˆï¼š

```json
{
  "scripts": {
    "gen-posts-index": "node scripts/gen-posts-index.js",
    "dev": "npm run gen-posts-index && next dev",
    "build": "npm run gen-posts-index && next build"
  }
}
```

# MDX æ¸²æŸ“å¼•æ“

é¡¹ç›®ä½¿ç”¨ Next.js å®˜æ–¹çš„ MDX è§£å†³æ–¹æ¡ˆï¼š

```json
{
  "dependencies": {
    "@mdx-js/loader": "^3.1.0",
    "@mdx-js/react": "^3.1.0",
    "@next/mdx": "^15.3.3",
    "@types/mdx": "^2.0.13"
  }
}
```

## æ’ä»¶é…ç½®

MDX å¤„ç†æµç¨‹ä¸­é›†æˆäº†å¤šä¸ªæ’ä»¶æ¥å¢å¼ºåŠŸèƒ½ï¼š

- **remark-frontmatter** - è§£æ YAML å‰ç½®å…ƒæ•°æ®
- **remark-gfm** - æ”¯æŒ GitHub Flavored Markdown
- **rehype-pretty-code** - è¯­æ³•é«˜äº®
- **rehype-slug** - è‡ªåŠ¨ç”Ÿæˆæ ‡é¢˜é”šç‚¹

## åŠ¨æ€è·¯ç”±å®ç°

<Tabs>
  <TabItem label="[slug]/page.tsx">
    ```tsx
    import { getAllPosts, getPostBySlug } from '@/lib/posts';
    import { notFound } from 'next/navigation';
    import { TableOfContents } from '@/components/table-of-contents';

    export interface Params {
      slug: string;
    }

    interface Props {
      params: Promise<Params>;
    }

    // é™æ€ç”Ÿæˆæ‰€æœ‰æ–‡ç« è·¯å¾„
    export async function generateStaticParams() {
      const posts = await getAllPosts();
      return posts.map((post) => ({ slug: post.slug }));
    }

    export const revalidate = 3600; // ISR é‡æ–°éªŒè¯é—´éš”
    export const dynamicParams = true;

    export default async function Page({ params }: Props) {
      const { slug } = await params;

      let Post, matter;

      try {
        // è·å–æ–‡ç« å…ƒæ•°æ®
        matter = await getPostBySlug(slug);
        // åŠ¨æ€å¯¼å…¥ MDX ç»„ä»¶
        const mod = await import(`@/contents/${slug}.mdx`);
        Post = mod.default;
      } catch (e) {
        return notFound();
      }

      return (
        <>
          {/* æ–‡ç« å¤´éƒ¨ä¿¡æ¯ */}
          <div className="my-10">
            <div className="text-fore mb-4 text-center text-3xl font-bold underline">
              {matter?.title}
            </div>
            <div className="text-fore/50 mb-4 text-center text-sm">{matter?.date}</div>
            <div className="flex justify-center gap-1">
              {matter?.category.map((item) => (
                <Link
                  key={item}
                  className="text-fore/60 bg-fore/10 rounded-xl px-2 py-1 text-xs"
                  href={`/categories/${item}`}
                >
                  #{item}
                </Link>
              ))}
            </div>
          </div>

          {/* æ–‡ç« å†…å®¹å’Œç›®å½• */}
          <div className="relative">
            <article className="prose-custom shiki">
              <Post />
            </article>
            <TableOfContents
              className="fixed top-40 right-10 hidden max-h-[60vh] w-64 overflow-auto xl:block"
              maxLevel={4}
            />
          </div>
        </>
      );
    }
    ```
  </TabItem>
</Tabs>

# Markdown æ ·å¼ç³»ç»Ÿ

## Tailwind CSS Typography

é¡¹ç›®ä½¿ç”¨ `@tailwindcss/typography` æ’ä»¶æä¾›åŸºç¡€çš„ Markdown æ ·å¼ï¼š

```css
@plugin "@tailwindcss/typography";
```

## è‡ªå®šä¹‰æ ·å¼ç±»

<Tabs>
  <TabItem label="prose-custom">
    ```css
    .prose-custom {
      @apply prose prose-gray dark:prose-invert max-w-none;
      @apply prose-headings:text-fore;
      @apply prose-h1:text-3xl prose-h1:font-bold prose-h1:mb-6;
      @apply prose-h2:text-2xl prose-h2:font-semibold prose-h2:mt-8 prose-h2:mb-4;
      @apply prose-h3:text-xl prose-h3:font-medium prose-h3:mt-6 prose-h3:mb-3;
      @apply prose-h4:text-lg prose-h4:font-medium prose-h4:mt-4 prose-h4:mb-2;
      @apply prose-p:text-fore prose-p:leading-relaxed;
      @apply prose-a:text-blue-400 prose-a:no-underline prose-a:hover:underline;
      @apply prose-strong:text-fore prose-strong:font-semibold;
      @apply prose-ul:text-fore prose-ol:text-fore;
      @apply prose-li:my-1;
      @apply prose-blockquote:border-l-blue-400 prose-blockquote:text-fore;
      @apply mx-auto max-w-4xl px-6 py-8;

      /* å›¾ç‰‡æ ·å¼ */
      img {
        @apply border-main/10 rounded-xl border object-cover dark:invert;
      }

      /* ä»£ç å—æ ·å¼ */
      pre {
        @apply bg-fore/5 dark:bg-fore/5 overflow-x-auto rounded-xl p-4;
        @apply border border-gray-200 dark:border-gray-700;
        font-family: inherit;
      }

      /* å†…è”ä»£ç æ ·å¼ */
      :not(pre) > code {
        @apply text-fore rounded-xl bg-gray-100 px-1.5 py-0.5 text-sm dark:bg-gray-800;
        @apply border border-gray-200 dark:border-gray-700;
        font-family: inherit;

        &::before,
        &::after {
          content: none; /* ç§»é™¤é»˜è®¤çš„å¼•å· */
        }
      }
    }
    ```
  </TabItem>
</Tabs>

# Toc

Toc å³ Table of Contentsï¼Œæ–‡ç« çš„ç›®å½•ã€‚

ç›´æ¥ `document.querySelectorAll` è·å–æ‰€æœ‰æ ‡é¢˜ï¼ˆh1-h4ï¼‰ï¼Œç„¶åæ ¹æ®æ ‡é¢˜çš„ level å’Œ id ç”Ÿæˆç›®å½•ã€‚

è·Ÿéšæ»šåŠ¨é«˜äº®å½“å‰æ ‡é¢˜åˆ™æ˜¯åˆ©ç”¨ `IntersectionObserver` æ¥ç›‘å¬æ ‡é¢˜çš„å¯è§æ€§ï¼Œç„¶åè®¾ç½® `activeId`ã€‚è¿™é‡Œåšè¿‡ç‰¹æ®Šä¼˜åŒ–ï¼Œåœ¨æ»šåŠ¨åœæ­¢åï¼Œè§¦å‘æ›´æ–° `activeId`ï¼Œé¿å…æ»šåŠ¨è¿‡ç¨‹ä¸­é¢‘ç¹è§¦å‘ã€‚

<Tabs>
  <TabItem label="table-of-contents.tsx">
    ```tsx
    'use client';

    import { useTableOfContentsHighlight } from '@/hooks/use-table-of-contents-highlight';
    import { cn } from '@/lib/utils';
    import { motion } from 'motion/react';
    import { useEffect, useState, useRef } from 'react';

    /**
     * Heading structure for the table of contents
     */
    export interface TocHeading {
      id: string;
      text: string;
      level: number;
    }

    /**
     * Props for the TableOfContents component
     */
    export interface TableOfContentsProps {
      /**
       * Custom class name for the container
       */
      className?: string;
      /**
       * Whether to show the table of contents (useful for responsive design)
       * @default true
       */
      show?: boolean;
      /**
       * Maximum heading level to include in TOC
       * @default 4
       */
      maxLevel?: number;
    }

    /**
     * Extract headings from the DOM and create TOC structure
     */
    const extractHeadings = (maxLevel: number): TocHeading[] => {
      const headingSelector = Array.from({ length: maxLevel }, (_, i) => `h${i + 1}`).join(', ');
      const headingElements = document.querySelectorAll(headingSelector);

      return Array.from(headingElements)
        .filter((heading) => heading.id && heading.textContent)
        .map((heading) => ({
          id: heading.id,
          text: heading.textContent?.trim() || '',
          level: parseInt(heading.tagName.substring(1), 10),
        }));
    };

    /**
     * Table of Contents component that highlights the currently visible section
     *
     * @param props - Component props
     * @returns JSX element for the table of contents
     */
    export const TableOfContents = ({
      className = '',
      show = true,
      maxLevel = 4,
    }: TableOfContentsProps) => {
      const [headings, setHeadings] = useState<TocHeading[]>([]);
      const { activeId, scrollToHeading } = useTableOfContentsHighlight();
      const activeItemRef = useRef<HTMLDivElement>(null);

      useEffect(() => {
        // Extract headings after component mounts
        const tocHeadings = extractHeadings(maxLevel);
        setHeadings(tocHeadings);
      }, [maxLevel]);

      useEffect(() => {
        if (activeId && activeItemRef.current) {
          const activeElement = activeItemRef.current;

          activeElement.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
          });
        }
      }, [activeId]);

      if (!show || headings.length === 0) {
        return null;
      }

      return (
        <nav
          className={`toc border-fore/10 border-l px-4 py-2 ${className}`}
          aria-label="Table of contents"
        >
          <div className="text-fore/70 mb-3 text-sm font-semibold tracking-wide uppercase">ç›®å½•</div>
          <div className="space-y-1">
            {headings.map((heading) => {
              const isActive = activeId === heading.id;
              const indent = (heading.level - 1) * 12; // 12px per level

              return (
                <div
                  key={heading.id}
                  style={{ paddingLeft: `${indent}px` }}
                  className="relative"
                  ref={isActive ? activeItemRef : null}
                >
                  <div
                    onClick={(e) => {
                      e.preventDefault();
                      scrollToHeading(heading.id);
                    }}
                    className={cn(
                      'toc-link hover:text-fore text-fore/60 block w-full cursor-pointer text-left text-sm transition-all duration-200',
                      isActive && 'text-fore',
                    )}
                  >
                    {heading.text}
                  </div>
                  {isActive && (
                    <motion.div
                      className="bg-fore absolute top-0 -left-4 h-full w-0.5"
                      layoutId="toc-active-indicator"
                    ></motion.div>
                  )}
                </div>
              );
            })}
          </div>
        </nav>
      );
    };
    ```  
  </TabItem>
  <TabItem label="use-table-of-contents-highlight.ts">
    ```ts
    import { useEffect, useState, useCallback, useRef } from 'react';

    /**
     * Options for the table of contents highlight hook
     */
    export interface UseTableOfContentsHighlightOptions {
      /**
       * Root margin for the intersection observer
       * @default '0px 0px -50% 0px'
       */
      rootMargin?: string;
      /**
       * Intersection threshold
       * @default 0.1
       */
      threshold?: number;
      /**
       * Selector for heading elements
       * @default 'h1, h2, h3, h4, h5, h6'
       */
      headingSelector?: string;
    }

    /**
     * A React hook that highlights table of contents items based on the currently visible heading
     */
    export const useTableOfContentsHighlight = (options: UseTableOfContentsHighlightOptions = {}) => {
      const {
        rootMargin = '0px 0px -50% 0px',
        threshold = 0.1,
        headingSelector = 'h1, h2, h3, h4, h5, h6',
      } = options;

      const [activeId, setActiveId] = useState<string>('');
      const [headingElements, setHeadingElements] = useState<Element[]>([]);
      const isScrollingRef = useRef(false);
      const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);

      /**
       * Scroll to a specific heading with smooth behavior
       */
      const scrollToHeading = useCallback((id: string) => {
        const element = document.getElementById(id);
        if (element) {
          // ç«‹å³è®¾ç½®ç›®æ ‡activeId
          setActiveId(id);
          element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }, []);

      useEffect(() => {
        // Get all heading elements that have an id
        const headings = Array.from(document.querySelectorAll(headingSelector)).filter(
          (heading) => heading.id,
        );

        setHeadingElements(headings);

        if (headings.length === 0) {
          return;
        }

        // Create intersection observer to track visible headings
        const observer = new IntersectionObserver(
          (entries) => {
            // å¦‚æœæ­£åœ¨æ»šåŠ¨ï¼Œä¸æ›´æ–°activeId
            if (isScrollingRef.current) return;

            // Find all currently intersecting entries
            const intersectingEntries = entries
              .filter((entry) => entry.isIntersecting)
              .sort((a, b) => {
                // Sort by position from top of viewport
                return a.boundingClientRect.top - b.boundingClientRect.top;
              });
            if (intersectingEntries.length > 0) {
              // Use the topmost intersecting heading
              const topEntry = intersectingEntries[0];
              setActiveId(topEntry.target.id);
            } else {
              // If no headings are intersecting, find the closest one above the viewport
              const allEntries = entries.sort((a, b) => {
                return a.boundingClientRect.top - b.boundingClientRect.top;
              });

              // Find the last heading that's above the viewport
              for (let i = allEntries.length - 1; i >= 0; i--) {
                const entry = allEntries[i];
                if (entry.boundingClientRect.top < 0) {
                  setActiveId(entry.target.id);
                  break;
                }
              }
            }
          },
          {
            threshold,
            rootMargin,
          },
        );

        // æ»šåŠ¨äº‹ä»¶å¤„ç†å™¨ï¼Œç”¨äºæ£€æµ‹ä»»ä½•æ»šåŠ¨è¡Œä¸º
        const handleScroll = () => {
          // æ ‡è®°æ­£åœ¨æ»šåŠ¨
          isScrollingRef.current = true;
          
          // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
          if (scrollTimeoutRef.current) {
            clearTimeout(scrollTimeoutRef.current);
          }
          
          // è®¾ç½®æ–°çš„å®šæ—¶å™¨ï¼Œæ»šåŠ¨åœæ­¢åä¸€æ®µæ—¶é—´é‡æ–°å¯ç”¨æ£€æµ‹
          scrollTimeoutRef.current = setTimeout(() => {
            isScrollingRef.current = false;
            // æ»šåŠ¨åœæ­¢åï¼Œæ‰‹åŠ¨è§¦å‘ä¸€æ¬¡æ£€æµ‹æ¥æ›´æ–°activeId
            observer.disconnect();
            headings.forEach((heading) => {
              observer.observe(heading);
            });
          }, 150); // 150ms çš„é˜²æŠ–æ—¶é—´
        };

        // Observe all heading elements
        headings.forEach((heading) => {
          observer.observe(heading);
        });

        // æ·»åŠ æ»šåŠ¨äº‹ä»¶ç›‘å¬
        window.addEventListener('scroll', handleScroll, { passive: true });

        // Cleanup observer on unmount
        return () => {
          observer.disconnect();
          window.removeEventListener('scroll', handleScroll);
          if (scrollTimeoutRef.current) {
            clearTimeout(scrollTimeoutRef.current);
          }
        };
      }, [headingSelector, rootMargin, threshold]);

      useEffect(() => {
        console.log('akira.activeId', activeId);
      }, [activeId]);

      return {
        activeId,
        scrollToHeading,
        headingElements,
      };
    };
    ```
  </TabItem>
</Tabs>